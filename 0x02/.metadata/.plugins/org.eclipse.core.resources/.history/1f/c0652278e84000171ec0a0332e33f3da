package com.lab31;

import javacard.framework.APDU;
import javacard.framework.Applet;
import javacard.framework.ISO7816;
import javacard.framework.ISOException;
import javacard.framework.Util;
import javacard.security.MessageDigest;
import javacard.security.PrivateKey;
import javacard.security.PublicKey;
import javacard.security.KeyBuilder;
import javacard.security.KeyPair;
import javacard.security.CryptoException;
import javacard.security.RSAPrivateKey;
import javacard.security.RSAPublicKey;


public class Task1 extends Applet {

			private static final byte HW_CLA = (byte) 0x80;
			
			private static final byte HW_INS_REC = (byte) 0x30;
			
			private static final byte HW_INS_MD5 = (byte) 0x01;//SW2:03 CryptoException NO_SUCH_ALG
			private static final byte HW_INS_SHA_256 = (byte) 0x04;//SW2:00
			private static final byte HW_INS_SHA_512 = (byte) 0x06;//SW2:03 CryptoException NO_SUCH_ALG
			
			private static final byte HW_INS_RSA_GEN = (byte) 0x10;
			
			private byte [] receivedData;
			private byte [] hashedData;
			
			private MessageDigest mesDig;
			private KeyPair keyPair;

    private Task1(byte[] bArray, short bOffset, byte bLength) {
        register();
    } // end of the constructor

    public static void install(byte[] bArray, short bOffset, byte bLength) {
        // create a Wallet applet instance
        new Task1(bArray, bOffset, bLength);
    } // end of install method

    @Override
    public boolean select() {
        return true;
    }// end of select method

    @Override
    public void process(APDU apdu) {
        if (selectingApplet()) {
          return;
        }

     byte[] buffer = apdu.getBuffer();

     byte CLA = (byte) (buffer[ISO7816.OFFSET_CLA] & 0xFF);

     byte INS = (byte) (buffer[ISO7816.OFFSET_INS] & 0xFF);

     if (CLA != HW_CLA) {

       ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);

     }

     switch (INS) {
      
     	//case HW_INS_REC:
     		//resendData(apdu,(byte)0);
     		//break;
     	case HW_INS_MD5:
     		try {
     			mesDig = MessageDigest.getInstance(MessageDigest.ALG_MD5, false);
     		}catch(CryptoException e){
     			ISOException.throwIt(e.getReason());
     			//NO_SUCH_ALGORITHM = SW2:0x03 
     		}
     		resendHash(apdu, MessageDigest.LENGTH_MD5);
     		mesDig.reset();
     		break;
     	case HW_INS_SHA_256:
     		try {
     			mesDig = MessageDigest.getInstance(MessageDigest.ALG_SHA_256, false);
     		}catch(CryptoException e){
     			ISOException.throwIt(e.getReason());
     			//NO_SUCH_ALGORITHM = SW2:0x03 
     		}
     		resendHash(apdu, MessageDigest.LENGTH_SHA_256);
     		mesDig.reset();
     		break;
     	case HW_INS_SHA_512:
     		try {
     			mesDig = MessageDigest.getInstance(MessageDigest.ALG_SHA_512, false);
     		}catch(CryptoException e){
     			ISOException.throwIt(e.getReason());
     			//NO_SUCH_ALGORITHM = SW2:0x03 
     		}
     		resendHash(apdu, MessageDigest.LENGTH_SHA_512);
     		mesDig.reset();
     		break;
     	case HW_INS_RSA_GEN:
     		generateKeyPair(apdu);
     		break;
     		
     	default:
     		ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
     }
     
   }
    
    void generateKeyPair(APDU apdu){
    	byte[] buffer = apdu.getBuffer();
    	
    	RSAPublicKey pubKey;
    	RSAPrivateKey privKey;
    	
    	pubKey = (RSAPublicKey)KeyBuilder.buildKey(KeyBuilder.ALG_TYPE_RSA_PUBLIC, KeyBuilder.LENGTH_RSA_512, false);
    	privKey = (RSAPrivateKey)KeyBuilder.buildKey(KeyBuilder.TYPE_RSA_PRIVATE, KeyBuilder.LENGTH_RSA_512, false);
    	keyPair = new KeyPair(pubKey, privKey);
    	keyPair.genKeyPair();
    	
    	pubKey=(RSAPublicKey)keyPair.getPublic();
    	privKey=(RSAPrivateKey)keyPair.getPrivate();
    	
    	
    	
    	//Util.arrayCopyNonAtomic(pubKey, (short) 0, buffer, (short) 0,
        	//	(short) pubKey.getSize());

        //apdu.setOutgoingAndSend((short) 0, respondeHashLength);
    }
    
    void resendHash(APDU apdu, byte hashLength){
    	byte[] buffer = apdu.getBuffer();
    	receiveData(apdu);
    	short recivedDataLength = (short) receivedData.length;
    	hashedData = new byte[(short)hashLength];
    	
    	try {
    		mesDig.doFinal(receivedData, (short)0, recivedDataLength, hashedData,
    			(short)0);
    	}catch(CryptoException e){
 			ISOException.throwIt(e.getReason());
 		}
    	
    	try {
        Util.arrayCopyNonAtomic(hashedData, (short) 0, buffer, (short) 0,
        		hashLength);
    	}catch(ArrayIndexOutOfBoundsException e){
    		ISOException.throwIt((short)0xAEAE);
    	}
        apdu.setOutgoingAndSend((short) 0, hashLength);
    	
    }
    
    void receiveData(APDU apdu) {

        byte[] buffer = apdu.getBuffer();

        short LC = apdu.getIncomingLength();

        short recvLen = apdu.setIncomingAndReceive();
        
        receivedData = new byte [recvLen];
        short receivedIdx = 0;

        short dataOffset = apdu.getOffsetCdata();        
        
        while (recvLen > 0) {
        	receivedData[receivedIdx]=buffer[dataOffset];
            recvLen = apdu.receiveBytes(dataOffset);
            receivedIdx++;
            dataOffset++;

        } 
    }
    
   
}
