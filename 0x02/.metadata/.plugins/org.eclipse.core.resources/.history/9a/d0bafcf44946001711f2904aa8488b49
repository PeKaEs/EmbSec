package com.lab31;

import javacard.framework.APDU;
import javacard.framework.Applet;
import javacard.framework.ISO7816;
import javacard.framework.ISOException;
import javacard.framework.Util;
import javacard.security.MessageDigest;
import javacard.security.PrivateKey;
import javacard.security.PublicKey;
import javacard.security.KeyBuilder;
import javacard.security.KeyPair;
import javacard.security.CryptoException;
import javacard.security.RSAPrivateKey;
import javacard.security.RSAPublicKey;


public class Task1 extends Applet {

	private static final byte HW_CLA = (byte) 0x80;
	
	private static final byte HW_INS_REC = (byte) 0x30;
	
	private static final byte HW_INS_MD5 = (byte) 0x01;//SW2:03 CryptoException NO_SUCH_ALG
	private static final byte HW_INS_SHA_256 = (byte) 0x04;//SW2:00
	private static final byte HW_INS_SHA_512 = (byte) 0x06;//SW2:03 CryptoException NO_SUCH_ALG
	
	private static final byte HW_INS_RSA_GEN = (byte) 0x10;
	
	private byte [] receivedData;
	private byte [] hashedData;
	
	private MessageDigest mesDig;
	private KeyPair keyPair;

private Task1(byte[] bArray, short bOffset, byte bLength) {
register();
} // end of the constructor

public static void install(byte[] bArray, short bOffset, byte bLength) {
// create a Wallet applet instance
new Task1(bArray, bOffset, bLength);
} // end of install method

@Override
public boolean select() {
return true;
}// end of select method

@Override
public void process(APDU apdu) {
if (selectingApplet()) {
  return;
}

byte[] buffer = apdu.getBuffer();

byte CLA = (byte) (buffer[ISO7816.OFFSET_CLA] & 0xFF);

byte INS = (byte) (buffer[ISO7816.OFFSET_INS] & 0xFF);

if (CLA != HW_CLA) {

ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);

}

switch (buffer[ ISO7816.OFFSET_INS]) {

	//case HW_INS_REC:
		//resendData(apdu,(byte)0);
		//break;
	case HW_INS_MD5:
		mesDig = MessageDigest.getInstance(MessageDigest.ALG_MD5, false);
		mesDig.reset();
		mesDig.doFinal(buffer, ISO7816.OFFSET_CDATA, buffer[ISO7816.OFFSET_LC],buffer,(short)0);
		apdu.setOutgoingAndSend((short) 0,MessageDigest.LENGTH_MD5);

		
		break;
	case HW_INS_SHA_256:
	
			mesDig = MessageDigest.getInstance(MessageDigest.ALG_SHA_256, false);
			mesDig.reset();
			mesDig.doFinal(buffer, ISO7816.OFFSET_CDATA, ISO7816.OFFSET_LC,buffer,(short)0);
			apdu.setOutgoingAndSend((short) 0,MessageDigest.LENGTH_SHA_256);
		break;
	case HW_INS_SHA_512:
		
			mesDig = MessageDigest.getInstance(MessageDigest.ALG_SHA_512, false);
			mesDig.reset();
			mesDig.doFinal(buffer, ISO7816.OFFSET_CDATA, ISO7816.OFFSET_LC,buffer,(short)0);
			apdu.setOutgoingAndSend((short) 0,MessageDigest.LENGTH_SHA_512);
		break;
	case HW_INS_RSA_GEN:
		generateKeyPair(apdu);
		break;
		
	default:
		ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
}

}

public  void generateKeyPair(APDU apdu){
byte[] buffer = apdu.getBuffer();
byte[] pubMod , privMod;
byte[] pubExp, privExp;
short pubSize,privSize;

RSAPublicKey pubKey = null;
RSAPrivateKey privKey;


	pubKey = (RSAPublicKey)KeyBuilder.buildKey(KeyBuilder.ALG_TYPE_RSA_PUBLIC, KeyBuilder.LENGTH_RSA_512, false);

privKey = (RSAPrivateKey)KeyBuilder.buildKey(KeyBuilder.TYPE_RSA_PRIVATE, KeyBuilder.LENGTH_RSA_512, false);

keyPair = new KeyPair(pubKey, privKey);

keyPair.genKeyPair();

pubKey=(RSAPublicKey)keyPair.getPublic();
privKey=(RSAPrivateKey)keyPair.getPrivate();



buffer= apdu.getBuffer();
short lenExp = pubKey.getExponent(buffer, (short)1);
buffer[0]=(byte)lenExp;
short lenMod = pubKey.getModulus(buffer, (short)(lenExp +2));
buffer[(short)(lenExp + 1)] = (byte)lenMod;
apdu.setOutgoingAndSend((short) 0, (short)(lenExp + lenMod +2));


}

void receiveData(APDU apdu) {

byte[] buffer = apdu.getBuffer();

short LC = apdu.getIncomingLength();

short recvLen = apdu.setIncomingAndReceive();

receivedData = new byte [recvLen];
short receivedIdx = 0;

short dataOffset = apdu.getOffsetCdata();        

while (recvLen > 0) {
	receivedData[receivedIdx]=buffer[dataOffset];
    recvLen = apdu.receiveBytes(dataOffset);
    receivedIdx++;
    dataOffset++;

} 
}
    
   
}
